# ============================================
# Docker Compose - Proyecto FCE_UNMSM_II
# Sistema de Gestión Web - UNMSM
# ============================================


version: '3.9'

services:
  # ====== BASE DE DATOS POSTGRESQL ======
  db:
    image: postgres:15-alpine
    container_name: fce_postgres
    restart: always
    
    environment:
      # IMPORTANTE: Estas variables vienen del archivo .env
      POSTGRES_DB: ${POSTGRES_DB:-fce_db}
      POSTGRES_USER: ${POSTGRES_USER:-fce_user}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}  
      # El "?error" hace que falle si no está definida - SEGURIDAD
      
      # Configuraciones adicionales
      POSTGRES_INITDB_ARGS: "--encoding=UTF8 --locale=es_PE.UTF-8"
      TZ: America/Lima
    
    ports:
      - "${DB_PORT:-5432}:5432"
    
    volumes:
      - pgdata:/var/lib/postgresql/data
      # Volumen persistente para no perder datos
      
      # Opcional: Scripts de inicialización
      # - ./server/database/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-fce_user} -d ${POSTGRES_DB:-fce_db}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    
    networks:
      - fce_network
    
    # Seguridad: limitar recursos
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 512M
        reservations:
          cpus: '0.5'
          memory: 256M

  # ====== API / BACKEND ======
  api:
    build:
      context: ./server
      dockerfile: Dockerfile
      args:
        NODE_ENV: ${NODE_ENV:-development}
    
    container_name: fce_api
    restart: always
    
    environment:
      NODE_ENV: ${NODE_ENV:-development}
      PORT: ${PORT:-4000}
      
      # Base de datos - conecta al servicio 'db'
      DB_HOST: db
      DB_PORT: 5432
      DB_NAME: ${POSTGRES_DB:-fce_db}
      DB_USER: ${POSTGRES_USER:-fce_user}
      DB_PASSWORD: ${POSTGRES_PASSWORD}  # ✅ CORREGIDO: usar la misma variable
      
      # Otras variables del .env
      SESSION_SECRET: ${SESSION_SECRET}
      CORS_ORIGIN: ${CORS_ORIGIN:-http://localhost}
      ADMIN_USER: ${ADMIN_USER}
      ADMIN_PASS: ${ADMIN_PASS}
    
    # Cargar archivo .env completo
    # env_file:
    #   - ./server/.env
    
    ports:
      - "${API_PORT:-4000}:4000"
    
    volumes:
      # SOLO para desarrollo - montar código fuente
      - ./server:/app
      - ./client:/app/client
      - /app/node_modules
      # node_modules como volumen anónimo para evitar conflictos
      
      # Volumen para uploads (persistente)
      - uploads_data:/app/uploads
    
    depends_on:
      db:
        condition: service_healthy
    
    networks:
      - fce_network
    
    # Healthcheck para la API
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:4000/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    
    # Seguridad: limitar recursos
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 512M

  # ====== NGINX (Servidor Web / Reverse Proxy) ======
  nginx:
    image: nginx:alpine
    container_name: fce_nginx
    restart: always
    
    ports:
      - "${NGINX_PORT:-80}:80"
      # Para HTTPS (configurar más adelante):
      # - "443:443"
    
    volumes:
      # Configuración de Nginx
      - ./nginx/default.conf:/etc/nginx/conf.d/default.conf:ro
      
      # Archivos estáticos del cliente
      - ./client:/usr/share/nginx/html:ro
      
      # Para logs personalizados
      - nginx_logs:/var/log/nginx
      
      # Para certificados SSL (cuando implementes HTTPS)
      # - ./nginx/ssl:/etc/nginx/ssl:ro
    
    depends_on:
      - api
    
    networks:
      - fce_network
    
    # Healthcheck
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost/health || exit 1"]
      interval: 30s
      timeout: 10s
    
    # Seguridad: limitar recursos
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 128M

# ====== VOLÚMENES ======
volumes:
  pgdata:
    driver: local
    # Datos de PostgreSQL - persistentes
  
  uploads_data:
    driver: local
    # Archivos subidos por usuarios
  
  nginx_logs:
    driver: local
    # Logs de Nginx

# ====== RED ======
networks:
  fce_network:
    driver: bridge
    # Red interna para comunicación entre contenedores

# ====== NOTAS DE USO ======
# 
# DESARROLLO:
# -----------
# 1. Crea tu archivo .env en la raíz: cp .env.example .env
# 2. Configura las variables en .env
# 3. Levanta los servicios: docker-compose up -d
# 4. Ver logs: docker-compose logs -f
# 5. Detener: docker-compose down
#
# PRODUCCIÓN:
# -----------
# 1. Usa docker-compose.prod.yml (crear separado)
# 2. Remover bind mounts (./server:/app)
# 3. Usar imágenes pre-construidas
# 4. Configurar HTTPS con certificados SSL
# 5. Usar secrets de Docker para credenciales
#
# COMANDOS ÚTILES:
# ----------------
# docker-compose up --build       # Reconstruir imágenes
# docker-compose exec api sh      # Entrar al contenedor API
# docker-compose exec db psql -U fce_user -d fce_db  # PostgreSQL CLI
# docker-compose down -v          # Eliminar TODO (incluyendo volúmenes)